//! ПакетЗапросов		Запрос[]
Перем ПакетЗапросов Экспорт;

//! \Перечисление ТипыЗапроса
//!  - Выборка
//!  - Уничтожение
Перем ТипыЗапроса Экспорт;

//! \Перечисление ТипыТаблиц
//!  - Таблица
//!  - ВложенныйЗапрос
Перем ТипыТаблиц Экспорт;

//! \Перечисление ТипыИнструкций
//!  - Нет
//!  - Сложить
//!  - Вычесть
//!  - Поделить
//!  - Умножить
//!  - Поместить
//!  - Вынуть
//!  - И
//!  - Или
//!  - Больше
//!  - Меньше
//!  - БольшеРавно
//!  - МеньшеРавно
//!  - Равно
//!  - НеРавно
//!  - Константа
//!  - Не
Перем ТипыИнструкций Экспорт;

//! \Блок Разбор текста {
Перем Положение;
Перем ХранилищеПоложений;
Перем НомерЗапроса;
Перем НомераПеременных;
Перем Цифры;
//! }

//! \Блок Отладка {
Перем УровеньЯмы;
Перем БуферЯмы;

Перем ИменаКоманд;
//! }

//! \Блок Среда исполнения {
Перем Стек;
Перем Переменные;
Перем КлючевыеЗначения;
//! }

#Если Скрипт Тогда

//! Текст запроса для разбора
Перем ТекстЗапроса Экспорт;

#КонецЕсли

//! Заглушка на время недоработок в движке скриптов Е8
Функция мЧисло(Знач Значение)
	
	#Если Скрипт Тогда
		
		Возврат 2143;
		
	#Иначе
		
		Возврат Число(Значение);
		
	#КонецЕсли
		
КонецФункции

//! Число без пробелов
Функция ЧБП(Число)
	
	#Если Скрипт Тогда
		// Пока что нет функции Формат
		Возврат "" + Число;
	#Иначе
		Возврат Формат(Число, "ЧГ=0");
	#КонецЕсли
	
КонецФункции

Процедура ЗапомнитьПоложение()
	ХранилищеПоложений.Добавить(Положение);
КонецПроцедуры

Процедура ВосстановитьПоложение()
	
	Перем К;
	
	К = ХранилищеПоложений.Количество() - 1;
	Положение = ХранилищеПоложений[К];
	ХранилищеПоложений.Удалить(К);
	
КонецПроцедуры

//! \Структура Запрос
Функция НовыйЗапрос()
	
	Перем Результат;
	
	Результат = Новый Структура;
	
	Результат.Вставить("ТипЗапроса"				, ТипыЗапроса.Выборка);		//!< ТипыЗапроса
	Результат.Вставить("Разрешенные"			, Ложь);
	Результат.Вставить("Первые"					, 0);						//!< Ограничение выборки
	Результат.Вставить("ИмяВременнойТаблицы"	, "");
	Результат.Вставить("ПоляВыборки"			, Новый Массив);			//!< ПолеВыборки[]
	Результат.Вставить("ТаблицыВыборки"			, Новый Массив);			//!< ТаблицаВыборки[]
	Результат.Вставить("УсловиеГде"				, Неопределено);			//!< Вычисление
	Результат.Вставить("ПоляГруппировки"		, Новый Массив);
	Результат.Вставить("ПоляУпорядочивания"		, Новый Массив);
	Результат.Вставить("УсловияИмеющие"			, Новый Массив);
	Результат.Вставить("ВложенныйЗапрос"		, Ложь);					//!< Запрос является вложенным
	Результат.Вставить("НумерацияПолейБезИмени" , 0);						//!< Служебное поле
	
	Возврат Результат;
	
КонецФункции

Функция НовыйВложенныйЗапрос()
	
	Перем Результат;
	
	Результат = НовыйЗапрос();
	Результат.ВложенныйЗапрос = Истина;
	
	Возврат Результат;
	
КонецФункции

//! \Структура ПолеВыборки
//!  - ПредВычисление			Вычисление[]			Вычисление до группировки
//!  - ПостВычисление			Вычисление[]			Вычисление после группировки
//!  - ГруппировочноеПоле		Булево
//!  - ИмяПоля					Строка
Функция НовоеПолеВыборки()
	
	Перем Результат;
	
	Результат = Новый Структура(
			"ПредВычисление, ПостВычисление, ГруппировочноеПоле, ИмяПоля"
			, Новый Массив, Новый Массив, Ложь, ""
	);
	
	Возврат Результат;
	
КонецФункции

//! \Структура ТаблицаВыборки
//!  - ТипТаблицы			ТипыТаблиц
//!  - ИмяТаблицы			Строка
//!  - Подзапрос			Запрос
//!  - Псевдоним			Строка
Функция НоваяТаблицаВыборки(Знач ИмяТаблицы = "")
	
	Если ЗначениеЗаполнено(ИмяТаблицы) Тогда
		Возврат Новый Структура("ТипТаблицы, ИмяТаблицы, Подзапрос, Псевдоним", ТипыТаблиц.Таблица, ИмяТаблицы, Неопределено, ИмяТаблицы);
	КонецЕсли;
	
	Возврат Новый Структура("ТипТаблицы, ИмяТаблицы, Подзапрос, Псевдоним", ТипыТаблиц.Подзапрос, "", Неопределено, "");
	
КонецФункции

//! \Структура Вычисление
//!  - ИмяПеременной			Строка
//!  - НаборИнструкций			Инструкция[]
Функция НовоеВычисление(Знач ИмяПеременной = "")
	
	Если ЗначениеЗаполнено(ИмяПеременной) Тогда
		Возврат Новый Структура("ИмяПеременной, НаборИнструкций", ИмяПеременной, Новый Массив);
	КонецЕсли;
	
	Возврат Новый Структура("ИмяПеременной, НаборИнструкций", ПолучитьИмяПеременной(), Новый Массив);
	
КонецФункции

//! \Структура Инструкция
//!  - ТипИнструкции			ТипыИнструкций
//!  - Параметр					*
Функция НоваяИнструкция(Знач ТипИнструкции = Неопределено, Параметр = Неопределено)
	
	Если ТипИнструкции = Неопределено Тогда
		Возврат Новый Структура("ТипИнструкции, Параметр", ТипыИнструкций.Нет, Параметр);
	КонецЕсли;
	
	Возврат Новый Структура("ТипИнструкции, Параметр", ТипИнструкции, Параметр);
	
КонецФункции

Функция ПолучитьИмяПеременной()
	НомераПеременных = НомераПеременных + 1;
	Возврат "П#" + ЧБП(НомераПеременных);
КонецФункции

Функция СимволЗапроса(Смещение = 0)
	Возврат Сред(ТекстЗапроса, Положение + Смещение, 1);
КонецФункции

Функция Шаг(РазмерШага = 1)
	Положение = Положение + РазмерШага;
КонецФункции

Функция Взять()
	
	Перем Р;
	
	Р = СимволЗапроса();
	Шаг();
	
	Возврат Р;
	
КонецФункции

//! Возвращает кусок текста запроса указанной длины
Функция КусокЗапроса(Длина)
	Возврат Сред(ТекстЗапроса, Положение, Длина);
КонецФункции

//! Истина, если достигнут конец текста запроса
Функция КонецТекстаЗапроса()
	Возврат Положение > СтрДлина(ТекстЗапроса);
КонецФункции

//! Пропускает незначащее содержимое текста запроса: пробелы, комментарии
Процедура ПропуститьМусор()
	
	Перем мПоложение;
	
	Пока Истина Цикл
		
		мПоложение = Положение;
		Пока Не КонецТекстаЗапроса() И ПустаяСтрока(СимволЗапроса()) Цикл
			Положение = Положение + 1;
		КонецЦикла;
		
		Если КусокЗапроса(2) = "//" Тогда
			Шаг(2);
			Пока Не КонецТекстаЗапроса() И (СимволЗапроса() <> Символы.ПС) Цикл
				Шаг(1);
			КонецЦикла;
		КонецЕсли;
		
		Если (Положение = мПоложение) Или КонецТекстаЗапроса() Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

//! Получает слово, способное быть определителем
Функция ОпределяющееСлово(НижнийРегистр = Истина)
	
	Перем Буквы, БуквыЦифры, Р;
	
	Буквы = "абвгдеёжзийклмнопрстуфхцчшщъыьйэюя_";
	БуквыЦифры = Буквы + "0123456789";
	Р = "";
	Если Найти(Буквы, нрег(СимволЗапроса())) <> 0 Тогда
		Пока Не КонецТекстаЗапроса() И (Найти(БуквыЦифры, нрег(СимволЗапроса())) <> 0) Цикл
			Р = Р + Взять();
		КонецЦикла;
	КонецЕсли;
	
	ПропуститьМусор();
	
	Если НижнийРегистр Тогда
		Возврат нрег(Р);
	КонецЕсли;
	
	Возврат Р;
	
КонецФункции

//! Считывает последовательный набор десятичных цифр
Функция НаборЦифр()
	
	Перем Р;
	
	Р = "";
	
	Пока Не КонецТекстаЗапроса() И (Найти(Цифры, СимволЗапроса()) <> 0) Цикл
		Р = Р + Взять();
	КонецЦикла;
	
	ПропуститьМусор();
	
	Возврат Р;
	
КонецФункции

//! Считывает слово, не сдвигая положения указателя
Функция ПредСлово()
	
	Перем Р;
	
	ЗапомнитьПоложение();
	Р = ОпределяющееСлово();
	ВосстановитьПоложение();
	
	Возврат Р;
	
КонецФункции

//! Истина, если Имя содержит имя агрегатной функции текста запроса
Функция ЭтоИтоговаяФункция(Имя)
	Возврат Ложь
		Или Имя = "сумма"
		Или Имя = "среднее"
		Или Имя = "минимум"
		Или Имя = "максимум"
		Или Имя = "количество"
		
		Или Имя = "sum"
		Или Имя = "avg"
		Или Имя = "min"
		Или Имя = "max"
		Или Имя = "count"
	;
КонецФункции


Процедура РазобратьВычисляемоеВыражениеХХ(Выражение, Слой)
	
	Выражение.ИмяПоля = ОпределяющееСлово();
	Выражение.ПостВычисление.Добавить(Результат.ИмяПоля);
	
КонецПроцедуры

//! Считывает числовую десятичную константу
Функция РазобратьЧисло()
	
	Перем ЦелаяЧасть, ДробнаяЧасть;
	
	ЦелаяЧасть = НаборЦифр();
	Если СимволЗапроса() = "." Тогда 
		
		Шаг();
		ДробнаяЧасть = НаборЦифр();
		
		Возврат мЧисло(ЦелаяЧасть + "." + ДробнаяЧасть);
		
	КонецЕсли;
	
	Возврат мЧисло(ЦелаяЧасть);
	
КонецФункции

// [НЕ]Слово[.Слово]|<Функция>(<Выражение00>)|[-]Число
Процедура РазобратьВычисляемоеВыражение40(Выражение, Слой)
	
	Перем Слово, Вычисление, НаборИнструкций, мНЕ, ИмяВложеннойПеременной;
	
	Вычисление = Выражение[Слой + "Вычисление"];
	НаборИнструкций = Вычисление[Вычисление.ВГраница()].НаборИнструкций;
	
	Если СимволЗапроса() = "(" Тогда
		
		Шаг(); // (
		ПропуститьМусор();
		
		РазобратьВычисляемоеВыражение00(Выражение, Слой);
		
		Шаг(); // )
		ПропуститьМусор();
		
		Возврат;
		
	КонецЕсли;
	
	Если Найти("0123456789", СимволЗапроса()) <> 0 Тогда
		
		НаборИнструкций.Добавить(НоваяИнструкция(ТипыИнструкций.Константа, РазобратьЧисло()));
		Возврат;
		
	КонецЕсли;
	
	Если СимволЗапроса() = "-" И Найти("0123456789", СимволЗапроса(+1)) <> 0 Тогда
		
		Шаг(); // -
		ПропуститьМусор();
		
		НаборИнструкций.Добавить(НоваяИнструкция(ТипыИнструкций.Константа, -РазобратьЧисло()));
		
		Возврат;
		
	КонецЕсли;
	
	мНЕ = Ложь;
	Слово = ОпределяющееСлово(Ложь);
	
	Если нрег(Слово) = "не" Тогда
		мНЕ = Истина;
		Слово = ОпределяющееСлово(Ложь);
	КонецЕсли;
	
	Если ЭтоИтоговаяФункция(нрег(Слово)) И (СимволЗапроса() = "(") Тогда
		
		Шаг(); // (
		ПропуститьМусор();
		
		Если Слой = "Пред" Тогда
			ВызватьИсключение "Использование вложенной агрегатной функции запрещено!";
		КонецЕсли;
		
		ИмяВложеннойПеременной = ПолучитьИмяПеременной();
		Выражение.ПредВычисление.Добавить(НовоеВычисление(ИмяВложеннойПеременной));
		
		РазобратьВычисляемоеВыражение00(Выражение, "Пред");
		
		Шаг(); // )
		ПропуститьМусор();
		
		Возврат;
		
	КонецЕсли;
	
	Ид = Слово;
	Пока СимволЗапроса() = "." Цикл
		
		Шаг(); // .
		ПропуститьМусор();
		
		Ид = Ид + "." + ОпределяющееСлово(Ложь);
		
	КонецЦикла;
	
	НаборИнструкций.Добавить(НоваяИнструкция(ТипыИнструкций.Поместить, Ид));
	Если мНЕ Тогда
		НаборИнструкций.Добавить(НоваяИнструкция(ТипыИнструкций.Не));
	КонецЕсли;
	
КонецПроцедуры

// * /
Процедура РазобратьВычисляемоеВыражение30(Выражение, Слой)
	
	Перем Знаки, мПредСлово;
	
	Вычисление = Выражение[Слой + "Вычисление"];
	НаборИнструкций = Вычисление[Вычисление.ВГраница()].НаборИнструкций;
	
	Знаки = Новый Массив;
	
	Пока Истина Цикл
		
		РазобратьВычисляемоеВыражение40(Выражение, Слой);
		
		Если СимволЗапроса() = "*" Тогда
			
			Шаг();
			ПропуститьМусор();
			
			Знаки.Добавить(ТипыИнструкций.Умножить);
			
		ИначеЕсли СимволЗапроса() = "/" Тогда
			
			Шаг();
			ПропуститьМусор();
			
			Знаки.Добавить(ТипыИнструкций.Поделить);
			
		Иначе
			
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого мЗнак Из Знаки Цикл
		НаборИнструкций.Добавить(НоваяИнструкция(мЗнак));
	КонецЦикла;
	
КонецПроцедуры

// + -
Процедура РазобратьВычисляемоеВыражение20(Выражение, Слой)
	
	Перем Знаки, мПредСлово;
	
	Вычисление = Выражение[Слой + "Вычисление"];
	НаборИнструкций = Вычисление[Вычисление.ВГраница()].НаборИнструкций;
	Знаки = Новый Массив;
	
	Пока Истина Цикл
		
		РазобратьВычисляемоеВыражение30(Выражение, Слой);
		
		Если СимволЗапроса() = "-" Тогда
			
			Шаг();
			ПропуститьМусор();
			
			Знаки.Добавить(ТипыИнструкций.Вычесть);
			
		ИначеЕсли СимволЗапроса() = "+" Тогда
			
			Шаг();
			ПропуститьМусор();
			
			Знаки.Добавить(ТипыИнструкций.Сложить);
			
		Иначе
			
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого мЗнак Из Знаки Цикл
		НаборИнструкций.Добавить(НоваяИнструкция(мЗнак));
	КонецЦикла;
	
КонецПроцедуры

// И ИЛИ
Процедура РазобратьВычисляемоеВыражение00(Выражение, Слой)
	
	Перем Знаки, мПредСлово;
	
	Вычисление = Выражение[Слой + "Вычисление"];
	НаборИнструкций = Вычисление[Вычисление.ВГраница()].НаборИнструкций;
	Знаки = Новый Массив;
	
	Пока Истина Цикл
		
		РазобратьВычисляемоеВыражение10(Выражение, Слой);
		
		мПредСлово = ПредСлово();
		Если мПредСлово = "или" Тогда
			
			ОпределяющееСлово();
			Знаки.Добавить(ТипыИнструкций.Или);
			
		ИначеЕсли мПредСлово = "и" Тогда
			
			ОпределяющееСлово();
			Знаки.Добавить(ТипыИнструкций.И);
			
		Иначе
			
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого мЗнак Из Знаки Цикл
		НаборИнструкций.Добавить(НоваяИнструкция(мЗнак));
	КонецЦикла;
	
КонецПроцедуры

// = <> >= <= > <
Процедура РазобратьВычисляемоеВыражение10(Выражение, Слой)
	
	Вычисление = Выражение[Слой + "Вычисление"];
	НаборИнструкций = Вычисление[Вычисление.ВГраница()].НаборИнструкций;
	
	РазобратьВычисляемоеВыражение20(Выражение, Слой);
	
	мЗнак = ТипыИнструкций.Нет;
	
	Если СимволЗапроса() = "=" Тогда
		
		Шаг();
		ПропуститьМусор();
		
		мЗнак = ТипыИнструкций.Равно;
		
	ИначеЕсли СимволЗапроса() = "<" Тогда
		
		Шаг();
		
		мЗнак = ТипыИнструкций.Меньше;
		
		Если СимволЗапроса() = "=" Тогда
			Шаг();
			мЗнак = ТипыИнструкций.МеньшеРавно;
		ИначеЕсли СимволЗапроса() = ">" Тогда
			Шаг();
			мЗнак = ТипыИнструкций.НеРавно;
		КонецЕсли;
		
		ПропуститьМусор();
		
	ИначеЕсли СимволЗапроса() = ">" Тогда
		
		Шаг();
		
		мЗнак = ТипыИнструкций.Больше;
		
		Если СимволЗапроса() = "=" Тогда
			Шаг();
			мЗнак = ТипыИнструкций.БольшеРавно;
		КонецЕсли;
		
		ПропуститьМусор();
		
	Иначе
		
		Возврат;
		
	КонецЕсли;
	
	РазобратьВычисляемоеВыражение20(Выражение, Слой);
	НаборИнструкций.Добавить(НоваяИнструкция(мЗнак));
		
КонецПроцедуры

Функция РазобратьВычисляемоеВыражение()
	
	Перем Результат;
	
	Результат = Новый Структура("ПредВычисление,ПостВычисление,ИмяПоля", Новый Массив, Новый Массив, "");
	
	Результат.ПостВычисление.Добавить(НовоеВычисление());
	
	РазобратьВычисляемоеВыражение00(Результат, "Пост");
	
	Если Результат.ПредВычисление.Количество() = 0 Тогда
		Результат.ПредВычисление = Результат.ПостВычисление;
		Результат.ПостВычисление = Новый Массив;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция КлючевоеСлово(Слово)
	
	Возврат Ложь
	
		Или Слово = "из"
		Или Слово = "поместить"
		Или Слово = "где"
		Или Слово = "по"
		Или Слово = "сгруппировать"
		Или Слово = "упорядочить"
		Или Слово = "соединение"
		Или Слово = "левое"
		Или Слово = "правое"
		Или Слово = "внутреннее"
		Или Слово = "полное"
		Или Слово = "внешнее"
		
		Или Слово = "from"
		Или Слово = "into"
		Или Слово = "where"
		Или Слово = "by"
		Или Слово = "group"
		Или Слово = "order"
		Или Слово = "join"
		Или Слово = "left"
		Или Слово = "right"
		Или Слово = "inner"
		Или Слово = "full"
		Или Слово = "outer"
	;
	
КонецФункции

Функция ПолеБезИмени(Запрос)
	
	Запрос.НумерацияПолейБезИмени = Запрос.НумерацияПолейБезИмени + 1;
	Возврат "Поле" + ЧБП(Запрос.НумерацияПолейБезИмени);
	
КонецФункции

#Если Скрипт Тогда

Процедура ЗаполнитьЗначенияСвойств(Приемник, Знач Источник, Знач СписокПолей)
	
	Перем П;
	
	Пока СписокПолей <> "" Цикл
		П = Найти(СписокПолей, ",");
		
		Если П = 0 Тогда
			
			Приемник[СписокПолей] = Источник[СписокПолей];
			СписокПолей = "";
			
		Иначе
			
			Приемник[Лев(СписокПолей, П - 1)] = Источник[Лев(СписокПолей, П - 1)];
			СписокПолей = Сред(СписокПолей, П + 1);
			
		КонецЕсли;
		
	КонецЦикла;
		
КонецПроцедуры
	
#КонецЕсли

Процедура РазобратьПоляВыборки(Запрос)
	
	Перем мСлово, мСиноним;
	
	Пока Истина Цикл
		
		ПолеВыборки = НовоеПолеВыборки();
		ЗаполнитьЗначенияСвойств(
			ПолеВыборки
			, РазобратьВычисляемоеВыражение()
			, "ПредВычисление,ПостВычисление,ИмяПоля"
		);
		Запрос.ПоляВыборки.Добавить(ПолеВыборки);
		мСлово = ПредСлово();
		Если мСлово = "как" Тогда
			
			ОпределяющееСлово(); // пропускаем
			ПолеВыборки.ИмяПоля = ОпределяющееСлово(Ложь);
			
		Иначе

			мСлово = ПредСлово();
			Если ЗначениеЗаполнено(мСлово) И (СимволЗапроса() <> ",") И Не КлючевоеСлово(мСлово) Тогда
				
				мСиноним = ОпределяющееСлово(Ложь);
				ПолеВыборки.ИмяПоля = мСиноним;
				
			Иначе
				
				// ВЫБРАТЬ ПростоПоле, ...
				Если Истина
					И (ПолеВыборки.ПостВычисление.Количество() = 0) И (ПолеВыборки.ПредВычисление.Количество() = 1)
					И (ПолеВыборки.ПредВычисление[0].НаборИнструкций.Количество() = 1)
					И (ПолеВыборки.ПредВычисление[0].НаборИнструкций[0].ТипИнструкции = ТипыИнструкций.Поместить)
					И (Найти(ПолеВыборки.ПредВычисление[0].НаборИнструкций[0].Параметр, ".") = 0)
					Тогда
					
					ПолеВыборки.ИмяПоля = ПолеВыборки.ПредВычисление[0].НаборИнструкций[0].Параметр;
					
				Иначе
					
					ПолеВыборки.ИмяПоля = ПолеБезИмени(Запрос);
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если СимволЗапроса() = "," Тогда 
			Шаг();
			ПропуститьМусор();
			Продолжить;
		КонецЕсли;
		
		Прервать;
		
	КонецЦикла; // Истина
	
	ПропуститьМусор();
	
КонецПроцедуры // РазобратьПоляВыборки

Процедура РазобратьОпределениеТаблицыИсточника(Запрос)
	
	Перем ИмяТаблицы, Таблица, мПсевдоним;
	
	Если СимволЗапроса() = "(" Тогда
		// Подзапрос
		
		Шаг(); // (
		ПропуститьМусор();
		
		Таблица = НоваяТаблицаВыборки();
		Таблица.Подзапрос = НовыйВложенныйЗапрос();
		РазобратьЗапрос(Таблица.Подзапрос);
		
		Запрос.ТаблицыВыборки.Добавить(Таблица);
		
		Шаг(); // )
		ПропуститьМусор();
		
		Если ПредСлово() = "как" Тогда
			// НАДО:: Обработать случай без "КАК"
			
			ОпределяющееСлово();
			Таблица.Псевдоним = ОпределяющееСлово(Ложь);
			
		КонецЕсли;
		
	Иначе
	
		ИмяТаблицы = ОпределяющееСлово(Ложь);
		
		Таблица = НоваяТаблицаВыборки(ИмяТаблицы);
		мПсевдоним = ПредСлово();
		
		Если мПсевдоним = "как" Тогда
			
			ОпределяющееСлово(); // как
			мПсевдоним = ОпределяющееСлово(Ложь);
			
		Иначе
			
			Если Не ПустаяСтрока(мПсевдоним) И Не КлючевоеСлово(мПсевдоним) Тогда
				
				// Это действительно псеводним таблицы
				ОпределяющееСлово();
				
			Иначе
				
				мПсевдоним = ИмяТаблицы;
				
			КонецЕсли;
			
		КонецЕсли;
		
		Таблица.Псевдоним = мПсевдоним;
		
		Запрос.ТаблицыВыборки.Добавить(Таблица);
	
	КонецЕсли;
	
КонецПроцедуры

Процедура РазобратьСписокТаблицИсточников(Запрос)
	
	РазобратьОпределениеТаблицыИсточника(Запрос);
	
	Если СимволЗапроса() = "," Тогда
		
		Пока СимволЗапроса() = "," Цикл
			
			Шаг(); // ,
			ПропуститьМусор();
			
			РазобратьОпределениеТаблицыИсточника(Запрос);
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура РазобратьСписокУсловийГде(Запрос)
	Запрос.УсловиеГде = РазобратьВычисляемоеВыражение();
КонецПроцедуры

Процедура РазобратьСписокУсловийИмеющие(Запрос)
КонецПроцедуры

Процедура РазобратьСписокПолейГруппировки(Запрос)
КонецПроцедуры

Процедура РазобратьСписокПолейУпорядочивания(Запрос)
КонецПроцедуры

Процедура ВеткаВыборки(Запрос)
	
	Перем мСлово;
	
	мСлово = ПредСлово();
	Пока (мСлово = "первые") Или (мСлово = "разрешенные") Цикл
		
		ОпределяющееСлово();
		
		Если мСлово = "первые" Тогда
			
			Запрос.Первые = мЧисло(НаборЦифр());
			
		ИначеЕсли мСлово = "разрешенные" Тогда
			
			Запрос.Разрешенные = Истина;
			
		КонецЕсли;
		
		мСлово = ПредСлово();
		
	КонецЦикла;
	
	РазобратьПоляВыборки(Запрос);
	
	мСлово = ПредСлово();
	Если мСлово = "поместить" Тогда
		ОпределяющееСлово(); // поместить
		Запрос.ИмяВременнойТаблицы = ОпределяющееСлово(Ложь);
	КонецЕсли;
	
	мСлово = ПредСлово();
	Если мСлово = "из" Тогда
		ОпределяющееСлово(); // из
		РазобратьСписокТаблицИсточников(Запрос);
	КонецЕсли;
	
	мСлово = ПредСлово();
	Если мСлово = "где" Тогда
		ОпределяющееСлово(); // где
		РазобратьСписокУсловийГде(Запрос);
	КонецЕсли;
	
	мСлово = ПредСлово();
	Если мСлово = "сгруппировать" Тогда
		ОпределяющееСлово(); // сгруппировать
		ОпределяющееСлово(); // по
		РазобратьСписокПолейГруппировки(Запрос);
	КонецЕсли;
	
	мСлово = ПредСлово();
	Если мСлово = "имеющие" Тогда
		ОпределяющееСлово();
		РазобратьСписокУсловийИмеющие(Запрос);
	КонецЕсли;
	
	мСлово = ПредСлово();
	Если мСлово = "упорядочить" Тогда
		ОпределяющееСлово(); // упорядочить
		ОпределяющееСлово(); // по
		РазобратьСписокПолейУпорядочивания(Запрос);
	КонецЕсли;
	
КонецПроцедуры

Процедура РазобратьЗапрос(Запрос)
	
	ПропуститьМусор();
	ОпределяющееСлово = ОпределяющееСлово();
	
	Если ОпределяющееСлово = "выбрать" Тогда
		
		ВеткаВыборки(Запрос);
		
	ИначеЕсли ОпределяющееСлово = "уничтожить" Тогда
		
		Запрос.ТипЗапроса = ТипыЗапроса.Уничтожение;
		Запрос.ИмяВременнойТаблицы = ОпределяющееСлово();
		
	Иначе
		
		ВызватьИсключение "Ожидается ключевое слово!";
		
	КонецЕсли;
КонецПроцедуры

Процедура РазобратьПакетЗапросов()
	
	Перем ОпределяющееСлово;
	
	ПакетЗапросов = Новый Массив;
	НомерЗапроса = -1;
	
	Положение = 1;
	НомераПеременных = 0;
	
	Пока Не КонецТекстаЗапроса() Цикл
		
		мЗапрос = НовыйЗапрос();
		ПакетЗапросов.Добавить(мЗапрос);
		НомерЗапроса = НомерЗапроса + 1;
		
		РазобратьЗапрос(мЗапрос);
		
		Если СимволЗапроса() = ";" Тогда
			Шаг();
			ПропуститьМусор();
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// RUNTIME

Функция НоваяСредаИсполнения()
	
	Перем Результат;
	
	Результат = Новый Структура;
	Результат.Вставить("Таблицы", Новый Структура);
	
	Возврат Результат;
	
КонецФункции

Процедура ПодготовитьТаблицуДанных(ТаблицаДанных, СредаИсполнения)
	
	Перем Результат;
	
	Если ТаблицаДанных.ТипТаблицы = ТипыТаблиц.Таблица Тогда
		
		Если Таблицы.Получить(ТаблицаДанных.ИмяТаблицы) = Неопределено Тогда
			// Готовая таблица из среды исполнения
		Иначе
			// Исходная таблица с данными
			СредаИсполнения.Таблицы.Вставить(ТаблицаДанных.Псевдоним, Таблицы.Получить(ТаблицаДанных.ИмяТаблицы));
		КонецЕсли;
		
		Возврат;
		
	КонецЕсли;
	
	Если ТаблицаДанных.ТипТаблицы = ТипыТаблиц.Подзапрос Тогда
		
		// Подзапрос
		Результат = ВыполнитьЗапрос(ТаблицаДанных.Подзапрос, СредаИсполнения);
		СредаИсполнения.Таблицы.Вставить(ТаблицаДанных.Псевдоним, Результат);
		
		Возврат;
		
	КонецЕсли;
	
КонецПроцедуры

Функция Изъять(Стек)
	
	Перем З;
	
	З = Стек[Стек.ВГраница()];
	Стек.Удалить(Стек.ВГраница());
	
	Возврат З;
	
КонецФункции

Функция ПолучитьЗначениеКонтекстаДанных(КонтекстДанных, Параметр)
	
	Перем мКолонкаТаблиц, мЗначение;
	
	Попытка
		
		Если КлючевыеЗначения.Свойство(Параметр, мЗначение) Тогда
			Возврат мЗначение;
		КонецЕсли;
		
	Исключение
	КонецПопытки;
	
	мКолонкаТаблиц = КонтекстДанных.КолонкиТаблиц.Получить(Параметр);
	Если мКолонкаТаблиц = Ложь Тогда
		ВызватьИсключение "Неоднозначное имя поля: " + Параметр;
	КонецЕсли;
	
	Если мКолонкаТаблиц = Неопределено Тогда
		ВызватьИсключение "Поле не обнаружено: " + Параметр;
	КонецЕсли;
	
	Возврат КонтекстДанных.СтрокаДанных[мКолонкаТаблиц.Имя];
	
КонецФункции

Процедура ВыполнитьНаборИнструкций(Стек, Знач НаборИнструкций, Знач КонтекстДанных)
	
	Перем А, Б;
	
	Для Каждого мИнструкция Из НаборИнструкций Цикл

		//"Нет,Сложить,Вычесть,Поделить,Умножить,Поместить,Вынуть,
		
		Если мИнструкция.ТипИнструкции = ТипыИнструкций.Нет Тогда
			Продолжить;
			
		ИначеЕсли мИнструкция.ТипИнструкции = ТипыИнструкций.Сложить Тогда
			
			Б = Изъять(Стек);
			А = Изъять(Стек);
			
			Стек.Добавить(А + Б);
			
		ИначеЕсли мИнструкция.ТипИнструкции = ТипыИнструкций.Вычесть Тогда
			
			Б = Изъять(Стек);
			А = Изъять(Стек);
			
			Стек.Добавить(А - Б);
			
		ИначеЕсли мИнструкция.ТипИнструкции = ТипыИнструкций.Поделить Тогда
			
			Б = Изъять(Стек);
			А = Изъять(Стек);
			
			Стек.Добавить(А / Б);
			
		ИначеЕсли мИнструкция.ТипИнструкции = ТипыИнструкций.Умножить Тогда
			
			Б = Изъять(Стек);
			А = Изъять(Стек);
			
			Стек.Добавить(А * Б);
			
		ИначеЕсли мИнструкция.ТипИнструкции = ТипыИнструкций.Поместить Тогда
			
			Стек.Добавить(ПолучитьЗначениеКонтекстаДанных(КонтекстДанных, мИнструкция.Параметр));
			
		ИначеЕсли мИнструкция.ТипИнструкции = ТипыИнструкций.Вынуть Тогда
			
			Изъять(Стек);
			
		//|И,Или,Больше,Меньше,БольшеРавно,МеньшеРавно,Равно,НеРавно,Константа",
		ИначеЕсли мИнструкция.ТипИнструкции = ТипыИнструкций.И Тогда
			
			Б = Изъять(Стек);
			А = Изъять(Стек);
			
			Стек.Добавить(А И Б);
			
		ИначеЕсли мИнструкция.ТипИнструкции = ТипыИнструкций.Или Тогда
			
			Б = Изъять(Стек);
			А = Изъять(Стек);
			
			Стек.Добавить(А Или Б);
			
		ИначеЕсли мИнструкция.ТипИнструкции = ТипыИнструкций.И Тогда
			
			Б = Изъять(Стек);
			А = Изъять(Стек);
			
			Стек.Добавить(А И Б);
			
		ИначеЕсли мИнструкция.ТипИнструкции = ТипыИнструкций.Больше Тогда
			
			Б = Изъять(Стек);
			А = Изъять(Стек);
			
			Стек.Добавить(А > Б);
			
		ИначеЕсли мИнструкция.ТипИнструкции = ТипыИнструкций.Меньше Тогда
			
			Б = Изъять(Стек);
			А = Изъять(Стек);
			
			Стек.Добавить(А < Б);
			
		ИначеЕсли мИнструкция.ТипИнструкции = ТипыИнструкций.БольшеРавно Тогда
			
			Б = Изъять(Стек);
			А = Изъять(Стек);
			
			Стек.Добавить(А >= Б);
			
		ИначеЕсли мИнструкция.ТипИнструкции = ТипыИнструкций.МеньшеРавно Тогда
			
			Б = Изъять(Стек);
			А = Изъять(Стек);
			
			Стек.Добавить(А <= Б);
			
		ИначеЕсли мИнструкция.ТипИнструкции = ТипыИнструкций.Равно Тогда
			
			Б = Изъять(Стек);
			А = Изъять(Стек);
			
			Стек.Добавить(А = Б);
			
		ИначеЕсли мИнструкция.ТипИнструкции = ТипыИнструкций.НеРавно Тогда
			
			Б = Изъять(Стек);
			А = Изъять(Стек);
			
			Стек.Добавить(А <> Б);
			
		ИначеЕсли мИнструкция.ТипИнструкции = ТипыИнструкций.Константа Тогда
			
			Стек.Добавить(мИнструкция.Параметр);
			
		ИначеЕсли мИнструкция.ТипИнструкции = ТипыИнструкций.Не Тогда
			
			Стек.Добавить(Не Изъять(Стек));
			
		КонецЕсли;
		
	КонецЦикла; // (НаборИнструкций)
	
КонецПроцедуры

Функция ВыполнитьПредВычисление(Знач Вычисления, Знач КонтекстДанных)
	
	Перем ПеременныеВычисления, Стек;
	
	ПеременныеВычисления = Новый Соответствие;
	
	Для Каждого Вычисление Из Вычисления Цикл
		
		Стек = Новый Массив;
		ВыполнитьНаборИнструкций(Стек, Вычисление.НаборИнструкций, КонтекстДанных);
		
		Если Стек.Количество() = 0 Тогда
			ВызватьИсключение "Внутренняя ошибка исполнения запроса";
		КонецЕсли;
		
		ПеременныеВычисления.Вставить(Вычисление.ИмяПеременной, Стек[0]);
		
	КонецЦикла;
	
	Возврат ПеременныеВычисления;
	
КонецФункции

Функция СоздатьКонтекстДанных(Знач КолонкиТаблиц, Знач СтрокаДанных)
	
	Перем Результат;
	
	Результат = Новый Структура;
	Результат.Вставить("КолонкиТаблиц", КолонкиТаблиц);
	Результат.Вставить("СтрокаДанных", СтрокаДанных);
	
	Возврат Результат;
	
КонецФункции

Функция ВыполнитьЗапрос(Запрос, СредаИсполнения)
	
	Перем Результат, ТаблицаДанных, СтрокаДанных, КолонкиТаблиц, мПорядокКолонки, ИсходнаяТаблицаДанных;

	Если Запрос.ТипЗапроса = ТипыЗапроса.Уничтожение Тогда
		СредаИсполнения.Удалить(Запрос.ИмяВременнойТаблицы);
		Возврат Неопределено;
	КонецЕсли;
	
	Для Каждого мТаблица Из Запрос.ТаблицыВыборки Цикл
		
		ПодготовитьТаблицуДанных(мТаблица, СредаИсполнения);
		
	КонецЦикла;
	
	ИсходнаяТаблицаДанных = Новый ТаблицаЗначений;
	КолонкиТаблиц = Новый Соответствие;
	
	// Создание колонок
	мПорядокКолонки = 0;
	Для Каждого мТаблица Из Запрос.ТаблицыВыборки Цикл
		
		ТаблицаДанных = СредаИсполнения.Таблицы[мТаблица.Псевдоним];
		
		Для Каждого мКолонка Из ТаблицаДанных.Колонки Цикл
			
			мПорядокКолонки = мПорядокКолонки + 1;
			мНоваяКолонка = ИсходнаяТаблицаДанных.Колонки.Добавить("Колонка" + ЧБП(мПорядокКолонки));
			КолонкиТаблиц.Вставить(мТаблица.Псевдоним + "." + мКолонка.Имя, мНоваяКолонка);
			
			Если КолонкиТаблиц.Получить(мКолонка.Имя) = Неопределено Тогда
				КолонкиТаблиц.Вставить(мКолонка.Имя, мНоваяКолонка);
			Иначе
				КолонкиТаблиц.Вставить(мКолонка.Имя, Ложь);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла; // создание колонок
	
	// Создание строк
	// НАДО: Сделать толковые связи таблиц
	//Для Каждого мТаблица Из Запрос.ТаблицыВыборки Цикл
	//	
	//	ТаблицаДанных = СредаИсполнения.Таблицы[мТаблица.Псевдоним];
	//	Для Каждого мСтрока Из ТаблицаДанных Цикл
	//		
	//		НоваяСтрока = ИсходнаяТаблицаДанных.Добавить();
	//		Для Каждого мКолонка Из ТаблицаДанных.Колонки Цикл
	//			
	//			мКолонкаРезультата = КолонкиТаблиц.Получить(мТаблица.ИмяТаблицы + "." + мКолонка.Имя);
	//			НоваяСтрока[мКолонкаРезультата.Имя] = мСтрока[мКолонка.Имя];
	//			
	//		КонецЦикла;
	//		
	//	КонецЦикла;
	//	
	//КонецЦикла; // создание строк
	УказателиСтрокТаблиц = Новый Массив(Запрос.ТаблицыВыборки.Количество());
	Для Инд = 1 По Запрос.ТаблицыВыборки.Количество() Цикл
		УказателиСтрокТаблиц[Инд - 1] = 0;
	КонецЦикла;
	
	К = 1;
	Пока К > 0 Цикл
		
		НоваяСтрока = ИсходнаяТаблицаДанных.Добавить();
		
		Для Инд = 1 По Запрос.ТаблицыВыборки.Количество() Цикл
			
			мТаблица = Запрос.ТаблицыВыборки[Инд - 1];
			ТаблицаДанных = СредаИсполнения.Таблицы[мТаблица.Псевдоним];
			СтрокаДанных = ТаблицаДанных[УказателиСтрокТаблиц[Инд - 1]];
			
			Для Каждого мКолонка Из ТаблицаДанных.Колонки Цикл
				
				мКолонкаРезультата = КолонкиТаблиц.Получить(мТаблица.Псевдоним + "." + мКолонка.Имя);
				НоваяСтрока[мКолонкаРезультата.Имя] = СтрокаДанных[мКолонка.Имя];
				
			КонецЦикла; // .Колонки
			
		КонецЦикла; // .ТаблицыВыборки
		
		// (FULL SCAN + INNER LOOPS) - безумная производительность :-)
		К = Запрос.ТаблицыВыборки.Количество();
		Пока К > 0 Цикл
			
			ТаблицаДанных = СредаИсполнения.Таблицы[Запрос.ТаблицыВыборки[К - 1].Псевдоним];
			
			Если УказателиСтрокТаблиц[К - 1] = ТаблицаДанных.Количество() - 1 Тогда
				
				УказателиСтрокТаблиц[К - 1] = 0;
				К = К - 1;
				
			Иначе
				
				УказателиСтрокТаблиц[К - 1] = УказателиСтрокТаблиц[К - 1] + 1;
				Прервать;
				
			КонецЕсли;
			
		КонецЦикла;
			
	КонецЦикла;
	
	Если Запрос.ТаблицыВыборки.Количество() = 0 Тогда
		// Нет раздела ИЗ
		ИсходнаяТаблицаДанных.Добавить();
	КонецЕсли;
	
	//Результат = ИсходнаяТаблицаДанных;
	Результат = Новый ТаблицаЗначений;
	Для Каждого мПоле Из Запрос.ПоляВыборки Цикл
		мКолонка = Результат.Колонки.Добавить(мПоле.ИмяПоля);
	КонецЦикла;
	
	Для Каждого мИсходнаяСтрока Из ИсходнаяТаблицаДанных Цикл
		
		мКонтекст = СоздатьКонтекстДанных(КолонкиТаблиц, мИсходнаяСтрока);
		
		Если Запрос.УсловиеГде <> Неопределено Тогда
			
			мЗначенияПеременных = ВыполнитьПредВычисление(Запрос.УсловиеГде.ПредВычисление, мКонтекст);
			мЗначениеУсловия = Ложь;
			Для Каждого мПеременная Из мЗначенияПеременных Цикл
				мЗначениеУсловия = мПеременная.Значение;
			КонецЦикла;
			
			Если Не мЗначениеУсловия Тогда
				// Не прошли по условию ГДЕ
				Продолжить;
			КонецЕсли;
			
		КонецЕсли;
		
		мНоваяСтрока = Результат.Добавить();
		
		Для Каждого мПоле Из Запрос.ПоляВыборки Цикл
			
			// НАДО: Запись промежуточных вычислений
			
			мЗначенияПеременных = ВыполнитьПредВычисление(мПоле.ПредВычисление, мКонтекст);
			
			Для Каждого мПеременная Из мЗначенияПеременных Цикл
				
				мНоваяСтрока[мПоле.ИмяПоля] = мПеременная.Значение;
				Прервать;
				
			КонецЦикла;
			
		КонецЦикла; // Для (ПоляВыборки)
		
		// НАДО: Не прокатить при упорядочивании
		Если (Запрос.Первые > 0) И (Результат.Количество() = Запрос.Первые) Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла; // Для (ИсходнаяТаблицаДанных)

	Если ЗначениеЗаполнено(Запрос.ИмяВременнойТаблицы) Тогда
		
		СредаИсполнения.Таблицы.Вставить(Запрос.ИмяВременнойТаблицы, Результат);
		Возврат Результат.Количество();
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Процедура ВыполнитьРазобранныйПакетЗапросов()
	
	Перем мПоле, Колонка, мТаблицы, СредаИсполнения, Р;
	
	Стек = Новый Массив;
	Переменные = Новый Структура;
	
	СредаИсполнения = НоваяСредаИсполнения();
	
	Для Каждого мЗапрос Из ПакетЗапросов Цикл
		
		Р = ВыполнитьЗапрос(мЗапрос, СредаИсполнения);
		Если ТипЗнч(Р) = Тип("ТаблицаЗначений") Тогда
			Результат = Р;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ВыполнитьПакетЗапросов() Экспорт
	
	РазобратьПакетЗапросов();
	ВыполнитьРазобранныйПакетЗапросов();
	
КонецПроцедуры


//! \Блок DEBUG {

//! \Блок YAML {
Процедура ВЯму()
	УровеньЯмы = УровеньЯмы + 1;
КонецПроцедуры

Процедура ИзЯмы()
	
	Если УровеньЯмы > 0 Тогда
		УровеньЯмы = УровеньЯмы - 1;
	КонецЕсли;
	
КонецПроцедуры

Процедура Яма(Текст)
	
	Перем П;
	
	БуферЯмы = БуферЯмы + Текст;
	
	П = Найти(БуферЯмы, Символы.ПС);
	Если П > 0 Тогда 
		Сообщить(Лев(БуферЯмы, П - 1));
		БуферЯмы = Сред(БуферЯмы, П + 1);
	КонецЕсли;

КонецПроцедуры

Процедура КинутьВЯму(Текст)
	
	Перем РТ, Инд;
	
	РТ = "";
	Для Инд = 1 По УровеньЯмы*2 - ?(Лев(Текст, 2) = "- ", 1, 0) Цикл
		РТ = РТ + "  ";
	КонецЦикла;
	
	Сообщить(РТ + Текст);
	
КонецПроцедуры

Процедура ОсвободитьЯму()
	
	Если Не ПустаяСтрока(БуферЯмы) Тогда
		Сообщить(БуферЯмы);
		БуферЯмы = "";
	КонецЕсли;
	
КонецПроцедуры
//! }

Процедура ОтладочныйВыводИнструкций(Вычисления)
	
	Для Каждого Вычисление Из Вычисления Цикл
		
		КинутьВЯму("- Переменная: " + Вычисление.ИмяПеременной);
		
		КинутьВЯму("Команды:");
		ВЯму();
		
		Для Каждого Инструкция Из Вычисление.НаборИнструкций Цикл
			КинутьВЯму("- Команда: " + ИменаКоманд.Получить( Инструкция.ТипИнструкции ) + ", Параметр: " + Инструкция.Параметр);
		КонецЦикла;
		
		ИзЯмы();
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ОтладочныйВыводЗапроса(мЗапрос) 
	
	КинутьВЯму("- Запрос:");
	
	ВЯму();
	
	Если мЗапрос.ТипЗапроса = ТипыЗапроса.Выборка Тогда
		
		Если ЗначениеЗаполнено(мЗапрос.ИмяВременнойТаблицы) Тогда
			КинутьВЯму("Тип: Создание");
			КинутьВЯму("ИмяВременнойТаблицы: " + мЗапрос.ИмяВременнойТаблицы);
		Иначе
			КинутьВЯму("Тип: Выборка");
		КонецЕсли;
		
	ИначеЕсли мЗапрос.ТипЗапроса = ТипыЗапроса.Уничтожение Тогда
		КинутьВЯму("Тип: Уничтожение");
		КинутьВЯму("ИмяВременнойТаблицы: " + мЗапрос.ИмяВременнойТаблицы);
		Возврат;
	КонецЕсли;
	
	КинутьВЯму("Таблицы: ");
	ВЯму();
	Для Каждого мТаблица Из мЗапрос.ТаблицыВыборки Цикл
		
		Если мТаблица.ТипТаблицы = ТипыТаблиц.Таблица Тогда
			КинутьВЯму("- " + мТаблица.Псевдоним + ": " + мТаблица.ИмяТаблицы);
		Иначе
			
			КинутьВЯму("- " + мТаблица.Псевдоним + ": ");
			
			ВЯму();
			
			ОтладочныйВыводЗапроса(мТаблица.Подзапрос);
			
			ИзЯмы();
			
		КонецЕсли;
		
	КонецЦикла;
	ИзЯмы(); // Таблицы
	
	Если мЗапрос.УсловиеГде <> Неопределено Тогда
		
		КинутьВЯму("Отбор: ");
		
		ВЯму();
			ОтладочныйВыводИнструкций(мЗапрос.УсловиеГде.ПредВычисление);
		ИзЯмы();
		
	КонецЕсли;
	
	КинутьВЯму("Поля: ");
	ВЯму();
	
	Для Каждого мПоле Из мЗапрос.ПоляВыборки Цикл
		
		КинутьВЯму("- ИмяПоля: " + мПоле.ИмяПоля);
		
		КинутьВЯму("Пред: ");
		
		ВЯму();
			ОтладочныйВыводИнструкций(мПоле.ПредВычисление);
		ИзЯмы();
		
		КинутьВЯму("Пост: ");
		
		ВЯму();
			ОтладочныйВыводИнструкций(мПоле.ПостВычисление);
		ИзЯмы();
		
	КонецЦикла;
	
	ИзЯмы(); // Поля
	
	ИзЯмы(); // Запрос
	
КонецПроцедуры

Процедура ОтладочныйВыводПакетаЗапросов() Экспорт
	
	УровеньЯмы = 0;
	БуферЯмы = "";
	
	КинутьВЯму("ПакетЗапросов:");
	Для Каждого мЗапрос Из ПакетЗапросов Цикл
		
		ВЯму();
		
		ОтладочныйВыводЗапроса(мЗапрос);
		
		ИзЯмы();
		
	КонецЦикла;
	
	ОсвободитьЯму();
	
КонецПроцедуры

Функция ОбратноеСоответствие(Структура)
	
	Перем Результат, Параметр;
	
	Результат = Новый Соответствие;
	Для Каждого Параметр Из Структура Цикл
		Результат.Вставить(Параметр.Значение, Параметр.Ключ);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

//! }

//! \Блок Объявление служебных сущностей {

Параметры = Новый Структура;
Таблицы = Новый Соответствие;
ТекстЗапроса = "";

ТипыЗапроса = Новый ФиксированнаяСтруктура("Выборка, Уничтожение", 1, 2);
ТипыТаблиц = Новый ФиксированнаяСтруктура("Таблица, Подзапрос", 1, 2);


ТипыИнструкций = Новый ФиксированнаяСтруктура(
	"Нет,Сложить,Вычесть,Поделить,Умножить,Поместить,Вынуть,
	|И,Или,Больше,Меньше,БольшеРавно,МеньшеРавно,Равно,НеРавно,Константа,Не",
	0,   1,   2,   3,   4,   5,   6,
	7,   8,   9,  10,  11,  12,  13,  14,  15,  16
);

ИменаКоманд = Новый ФиксированноеСоответствие( ОбратноеСоответствие(ТипыИнструкций) );

ХранилищеПоложений = Новый Массив;
Цифры = "0123456789";
КлючевыеЗначения = Новый ФиксированнаяСтруктура("Ложь, Истина, Null, Неопределено", Ложь, Истина, Null, Неопределено);

//! }

#Если Скрипт Тогда

	УровеньЯмы = 0;
	БуферЯмы = "";

	ТекстЗапроса = 
		"ВЫБРАТЬ Артикул, Количество, Сумма, Сумма/Количество КАК Цена
		|ПОМЕСТИТЬ ВтПродажи
		|ИЗ Продажи
		|;
		|ВЫБРАТЬ Артикул, Количество, Сумма, Цена
		|ИЗ ВтПродажи";
	РазобратьПакетЗапросов();

	ОтладочныйВыводПакетаЗапросов();

#КонецЕсли
